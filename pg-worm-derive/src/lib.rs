mod parse;

use darling::FromDeriveInput;
use proc_macro::{self, TokenStream};
use quote::quote;
use syn::parse_macro_input;

use parse::ModelInput;

/// Automatically implement `Model` for your struct.
///
/// ## Attributes
///  * `table` - for structs:
///      - `table_name: String`: optional. Overwrites the table name
///  * `column` - for struct fields:
///      - `dtype: String`: optional. Overwrites the postgres datatype
///      - `unique: bool`: optional, default: `false`. Enables the `unqiue` constraint.
///      - `auto: bool`: optional, default: `false`. This autogenerated the
///        values.
///      - `column_name: String`: optional. Overwrites the column name.
#[proc_macro_derive(Model, attributes(table, column))]
pub fn derive(input: TokenStream) -> TokenStream {
    let opts = ModelInput::from_derive_input(&parse_macro_input!(input)).unwrap();

    let ident = opts.ident();

    let table_name = opts.table_name();

    // Retrieve the struct's fields
    let fields = opts.fields();

    if opts.n_fields() == 0 {
        panic!("struct must have at least one field to become a `Model`")
    }

    // Get the fields' idents
    let field_idents = fields.map(|f| f.clone().ident()).collect::<Vec<_>>();

    let insert_fields = opts.insert_fields().collect::<Vec<_>>();
    let insert_columns_counter = (1..=insert_fields.len())
        .map(|i| format!("${i}"))
        .collect::<Vec<_>>()
        .join(", ");

    let insert_columns = insert_fields
        .clone()
        .into_iter()
        .map(|f| f.column_name())
        .collect::<Vec<_>>()
        .join(", ");

    let insert_columns_idents = insert_fields
        .clone()
        .into_iter()
        .map(|f| f.ident())
        .collect::<Vec<_>>();
    let insert_column_dtypes = insert_fields
        .clone()
        .into_iter()
        .map(|f| f.insert_arg_type())
        .collect::<Vec<_>>();

    let table_creation_sql = opts.table_creation_sql();

    // Generate the needed impl code
    let output = quote!(
        impl<'a> TryFrom<&'a pg_worm::Row> for #ident {
            type Error = pg_worm::pg::Error;

            fn try_from(value: &'a pg_worm::Row) -> Result<#ident, Self::Error> {
                // Parse each column into the corresponding field
                Ok(#ident {
                    #(#field_idents: value.try_get(stringify!(#field_idents))?),*
                })
            }
        }

        #[pg_worm::async_trait]
        impl Model<#ident> for #ident {
            fn _table_creation_sql() -> &'static str {
                #table_creation_sql
            }

            async fn select() -> Vec<#ident> {
                let client = pg_worm::_get_client().expect("not connected to db");
                let rows = client.query(format!("SELECT * FROM {}", #table_name).as_str(), &[]).await.unwrap();
                rows.iter().map(|r| #ident::try_from(r).expect("couldn't parse data")).collect()
            }

            async fn select_one() -> Option<#ident> {
                let client = pg_worm::_get_client().expect("not connected to db");
                let rows = client.query(format!("SELECT * FROM {} LIMIT 1", #table_name).as_str(), &[]).await.unwrap();
                if rows.len() != 1 {
                    return None;
                }
                Some(#ident::try_from(&rows[0]).unwrap())
            }
        }

        impl #ident {
            /// Insert a new entity into the database.
            ///
            /// For columns which are autogenerated (like in the example below, `id`),
            /// no value has to be specified.
            ///
            /// # Example
            ///
            /// ```ignore
            /// use pg_worm::Model;
            ///
            /// #[derive(Model)]
            /// struct Book {
            ///     #[column(dtype = "BIGSERIAL")]
            ///     id: i64,
            ///     #[column(dtype = "TEXT")]
            ///     title: String
            /// }
            ///
            /// async fn some_func() -> Result<(), pg_worm::Error> {
            ///     Book::insert("Foo".to_string()).await?;
            /// }
            /// ```
            pub async fn insert(
                #(#insert_columns_idents: #insert_column_dtypes),*
            ) -> Result<(), pg_worm::Error> {
                let stmt = format!(
                    "INSERT INTO {} ({}) VALUES ({})",
                    #table_name,
                    #insert_columns,
                    #insert_columns_counter
                );

                let client = pg_worm::_get_client()?;

                client.execute(
                    stmt.as_str(),
                    &[
                        #(&#insert_columns_idents), *
                    ]
                ).await?;

                Ok(())
            }
        }
    );

    output.into()
}
