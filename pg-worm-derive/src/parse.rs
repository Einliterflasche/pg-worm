use std::collections::HashMap;

use darling::{ast::Data, FromDeriveInput, FromField, FromMeta, export::NestedMeta};
use postgres_types::Type;
use proc_macro2::TokenStream;
use quote::{quote, ToTokens};
use syn::{Ident, Path, Meta};

#[derive(FromDeriveInput)]
#[darling(attributes(table), supports(struct_named))]
pub struct ModelInput {
    ident: syn::Ident,
    data: Data<(), ModelField>,
    table_name: Option<String>,
}

#[derive(Clone, FromField)]
#[darling(attributes(column))]
pub struct ModelField {
    ident: Option<syn::Ident>,
    ty: syn::Type,
    dtype: Option<String>,
    column_name: Option<String>,
    #[darling(default)]
    auto: bool,
    #[darling(default)]
    primary_key: bool,
    #[darling(default)]
    unique: bool,
    #[darling(default)]
    references: ReferencesInput
}

#[derive(Clone, Default)]
pub struct ReferencesInput {
    paths: Vec<Path>
}

impl ModelInput {
    pub fn table_name(&self) -> String {
        if let Some(table_name) = &self.table_name {
            return table_name.clone();
        }

        self.ident.to_string().to_lowercase()
    }

    pub const fn ident(&self) -> &Ident {
        &self.ident
    }

    pub fn n_fields(&self) -> usize {
        match &self.data {
            Data::Struct(fields) => fields.fields.len(),
            _ => panic!("only named struct supported"),
        }
    }

    pub fn fields(&self) -> impl Iterator<Item = &ModelField> {
        match &self.data {
            Data::Struct(fields) => fields.fields.iter(),
            _ => panic!("only named struct supported"),
        }
    }

    pub fn insert_fields(&self) -> impl Iterator<Item = &ModelField> {
        self.fields().filter(|f| !f.auto_generated())
    }

    pub fn table_creation_sql(&self) -> String {
        format!(
            "DROP TABLE IF EXISTS {} CASCADE; CREATE TABLE {} ({})",
            self.table_name(),
            self.table_name(),
            self.fields()
                .map(|f| f.column_creation_sql())
                .collect::<Vec<String>>()
                .join(", ")
        )
    }

    pub fn impl_column_consts(&self) -> TokenStream {
        let column_consts = self.fields().map(|f| f.column_const());
        let ident = &self.ident;
        quote!(
            impl #ident {
                #(#column_consts) *
            }
        )
    }

    pub fn impl_insert(&self) -> TokenStream {
        let table_name = self.table_name();

        let column_names = self.insert_fields()
            .map(|f| f.column_name())
            .collect::<Vec<_>>()
            .join(", ");

        let column_counter = (1..=self.insert_fields().collect::<Vec<_>>().len())
            .map(|i| format!("${i}"))
            .collect::<Vec<_>>()
            .join(", ");

        let column_idents = self.insert_fields()
            .map(|f| f.ident())
            .collect::<Vec<_>>();
        let column_dtypes = self.insert_fields()
            .map(|f| f.insert_arg_type())
            .collect::<Vec<_>>();
        
        quote!(
            /// Insert a new entity into the database.
            ///
            /// For columns which are autogenerated (like in the example below, `id`),
            /// no value has to be specified.
            ///
            /// # Example
            ///
            /// ```ignore
            /// use pg_worm::Model;
            ///
            /// #[derive(Model)]
            /// struct Book {
            ///     #[column(dtype = "BIGSERIAL")]
            ///     id: i64,
            ///     #[column(dtype = "TEXT")]
            ///     title: String
            /// }
            ///
            /// async fn some_func() -> Result<(), pg_worm::Error> {
            ///     Book::insert("Foo".to_string()).await?;
            /// }
            /// ```
            pub async fn insert(
                #(#column_idents: #column_dtypes),*
            ) -> Result<(), pg_worm::Error> {
                // Prepare sql statement
                let stmt = format!(
                    "INSERT INTO {} ({}) VALUES ({})",
                    #table_name,
                    #column_names,
                    #column_counter
                );

                // Retrieve the client
                let client = pg_worm::_get_client()?;

                // Execute the query
                client.execute(
                    stmt.as_str(),
                    &[
                        #(&#column_idents), *
                    ]
                ).await?;

                // Everything's fine
                Ok(())
            }
        )
    }

    pub fn references(&self) -> HashMap<String, Vec<Path>> {
        let refs: HashMap<String, Vec<Path>> = self.fields().map(|f|
            (f.column_name(), f.references().clone())
        ).collect();

        refs
    }
}

impl ModelField {
    pub fn auto_generated(&self) -> bool {
        self.auto
            || self.primary_key
            || self.dtype.as_ref().is_some()
                && self
                    .dtype
                    .as_ref()
                    .unwrap()
                    .to_lowercase()
                    .contains("serial")
    }

    pub fn ty(&self) -> &syn::Type {
        &self.ty
    }

    /// Get the field's identifier.
    pub fn ident(&self) -> Ident {
        self.ident
            .clone()
            .expect("struct {} should only contain named fields")
    }

    /// Ge the column's name.
    pub fn column_name(&self) -> String {
        if let Some(column_name) = &self.column_name {
            return column_name.clone();
        }

        self.ident().to_string().to_lowercase()
    }

    /// Get the column's PostgreSQL datatype.
    pub fn pg_datatype(&self) -> Type {
        if let Some(dtype) = &self.dtype {
            let ty = match dtype.to_lowercase().as_str() {
                "bool" | "boolean" => Type::BOOL,
                "text" => Type::TEXT,
                "int" | "integer" | "int4" => Type::INT4,
                "bigint" | "int8" => Type::INT8,
                "smallint" | "int2" => Type::INT2,
                "real" => Type::FLOAT4,
                "double precision" => Type::FLOAT8,
                "bigserial" => Type::INT8,
                _ => panic!("couldn't find postgres type `{}`", dtype),
            };

            return ty;
        }

        match self.ty() {
            syn::Type::Path(type_path) => match type_path
                    .path
                    .segments
                    .first().unwrap()
                    .ident.to_string().as_str() {
                        "String" => Type::TEXT,
                        "i64" => Type::INT8,
                        "f32" => Type::FLOAT4,
                        "f64" => Type::FLOAT8,
                        "bool" => Type::BOOL,
                        _ => todo!(
                            "cannot guess postgres type for field {:?}, please provide via attribute: `#[column(dtype = 'DataType']`", 
                            self.ident().to_string()
                        )
                    },
            syn::Type::Reference(_) => panic!("field {:?} may not be reference", self.ident().to_string()),
            _ => todo!(
                "cannot guess postgres type for field {:?}, please provide via attribute: `#[column(dtype = 'DataType']`", 
                self.ident().to_string()
            )
        }
    }

    /// Get the SQL representing the column needed
    /// for creating a table.
    ///
    /// # Example
    ///
    pub fn column_creation_sql(&self) -> String {
        if self.primary_key && self.unique {
            panic!(
                "primary keys are unique, remove unnecessary `unique` on {:?}",
                self.ident().to_string()
            )
        }

        // The list of "args" for the sql statement.
        // Includes at least the column name and datatype.
        let mut args = vec![self.column_name(), self.pg_datatype().to_string()];

        // This macro allows adding an arg to the list
        // under a condition.
        macro_rules! arg {
            ($cond:expr, $sql:literal) => {
                if $cond {
                    args.push($sql.to_string());
                }
            };
        }

        // Add possible args
        arg!(self.primary_key, "PRIMARY KEY");
        arg!(self.auto, "GENERATED ALWAYS AS IDENTITY");
        arg!(self.unique, "UNIQUE");

        // Join the args, seperated by a space and return them
        args.join(" ")
    }

    pub fn insert_arg_type(&self) -> TokenStream {
        let ty = self.ty().to_token_stream();
        if ty.to_string() == "String" {
            return quote!(impl Into<String> + pg_worm::pg::types::ToSql + Sync);
        }
        ty
    }

    pub fn column_const(&self) -> TokenStream {
        let name = self.column_name();
        let ident = self.ident();
        let rs_type = self.ty();

        quote!(
            #[allow(non_upper_case_globals)]
            pub const #ident: pg_worm::Column<#rs_type> = pg_worm::Column::new(#name);
        )
    }

    pub fn references(&self) -> &Vec<Path> {
        &self.references.paths
    }
}

impl FromMeta for ReferencesInput {
    fn from_list(items: &[NestedMeta]) -> Result<Self, darling::Error> {
        let mut paths: Vec<Path> = Vec::new();

        for i in items {
            match i {
                NestedMeta::Meta(meta) => match meta {
                    Meta::Path(path) => { 
                        paths.push(path.clone());
                        continue;
                    },
                    _ => (),
                },
                _ => ()
            }
            return Err(darling::Error::unsupported_shape("references should be a list of columns"))
        }

        Ok(ReferencesInput { paths })
    }
}
