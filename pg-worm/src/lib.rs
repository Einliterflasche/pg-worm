//! # `pg-worm`
//! ### *P*ost*g*reSQL's *W*orst *ORM*
//! `pg-worm` is a straightforward, fully typed, async ORM and Query Builder for PostgreSQL.
//! Well, at least that's the goal.
//!
//! This library is based on [`tokio_postgres`](https://docs.rs/tokio-postgres/0.7.8/tokio_postgres/index.html)
//! and is intended to be used with [`tokio`](https://tokio.rs/).
//!
//! ## Usage
//! Fortunately, using `pg_worm` is very easy.
//!
//! Simply derive the [`Model`] trait for your type, connect to your database
//! and you are ready to go!
//!
//! Here's a quick example:
//!
//! ```rust
//! use pg_worm::prelude::*;
//!
//! #[derive(Model)]
//! struct Book {
//!     // An auto-generated primary key column
//!     #[column(primary_key, auto)]
//!     id: i64,
//!     title: String,
//!     author_id: i64
//! }
//!
//! #[derive(Model)]
//! struct Author {
//!     #[column(primary_key, auto)]
//!     id: i64,
//!     name: String
//! }
//!
//! #[tokio::main]
//! async fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     // First create a connection. This can be only done once.
//!     connect_pool(Config::from_str("postgres://postgres:postgres@localhost:5432")?).await?;
//!
//!     // Then, create tables for your models.
//!     // Use `register!` if you want to fail if a
//!     // table with the same name already exists.
//!     //
//!     // `force_register` drops the old table,
//!     // which is useful for development.
//!     //
//!     // If your tables already exist, skip this part.
//!     force_register!(Author, Book)?;
//!
//!     // Next, insert some data.
//!     // This works by passing values for all
//!     // fields which aren't autogenerated.
//!     Author::insert("Stephen King").await?;
//!     Author::insert("Martin Luther King").await?;
//!     Author::insert("Karl Marx").await?;
//!     Book::insert("Foo - Part I", 1).await?;
//!     Book::insert("Foo - Part II", 2).await?;
//!     Book::insert("Foo - Part III", 3).await?;
//!
//!     // Let's start with a simple query for all books:
//!     let books = Book::select().await?; // Vec<Book>
//!     assert_eq!(books.len(), 3);
//!
//!     // You can also search for a specific book.
//!     // Adding a `WHERE` clause is as simple as
//!     // calling a method on the respective field:
//!     let book = Book::select_one()
//!         .where_(Book::title.eq(&"Foo - Part I".to_string()))
//!         .await?; // Option<Book>
//!     assert!(book.is_some());
//!
//!     // Or update exsisting records:
//!     let books_updated = Book::update()
//!         .set(Book::title, &"Foo - Part III".to_string())
//!         .where_(Book::title.eq(&"Foo - Part II".to_string()))
//!         .await?; // u64
//!     assert_eq!(books_updated, 1);
//!
//!     // Or delete a book, you don't like:
//!     let books_deleted = Book::delete()
//!         .where_(Book::title.eq(&"Foo - Part III".to_string()))
//!         .await?; // u64
//!     assert_eq!(books_deleted, 2);
//!
//!     Ok(())
//! }
//! ```
//!
//! If you want to see more code examples, have a look at the [tests directory](https://github.com/Einliterflasche/pg-worm/tree/main/pg-worm/tests).
//!
//! ## Query Builders
//! As you can see in the above example, `pg_worm` allows you to build queries by chaining methods on so called 'builders'.
//! For each query type `pg_worm` provides a respective builder (except for `INSERT` which is handled differently).
//!
//! These builders expose a set of methods for building queries. Here's a list of them:
//!
//! Method | Description | Availability
//! -------|-------------|-------------
//! `where_` | Attach a `WHERE` clause to the query. | All builders ([`Select`], [`Update`], [`Delete`])
//! `set` | `SET` a column's value. Note: this method has to be called at least once before you can execute the query. | `Update`
//! `limit`, `offset` | Attach a [`LIMIT` or `OFFSET`](https://www.postgresql.org/docs/current/queries-limit.html) to the query. | `Select`
//!
//! ## Filtering using `WHERE`
//! `where_()` can be used to easily include `WHERE` clauses in your queries.
//!
//! This is done by passing a [`Where`] object which can be constructed by calling methods on the respective column.
//! `pg_worm` automatically constructs a constant for each field
//! of your `Model`.
//!
//! A practical example could look like this:
//!
//! ```ignore
//! let where_: Where<'_> = MyModel::my_field.eq(&5);
//! ```
//! ### Available methods
//!
//! Currently, the following methods are implemented:
//!
//! Function | Description | Availability
//! ---------|-------------|-------------
//! `eq` | Checks for equality. | Any type
//! `gt`, `gte`, `lt`, `lte` | Check whether this column's value is greater than, etc than some other value. | Any type which implement [`PartialOrd`](https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html). Note: It's not guaranteed that Postgres supports these operator for a type just because it's `PartialOrd`. Be sure to check the documentation beforehand.
//! `null`, `not_null` | Checks whether a column is `NULL`. | Any `Option<T>`. All other types are not `NULL`able and thus guaranteed not to be `NULL`.
//! `contains`, `contains_not`, `contains_all`, `conatains_none`, `contains_any` | Array operations. Check whether this column's array contains a value, a value _not_, or any/all/none values of another array. | Any `Vec<T>`.
//!
//! ### Boolean logic
//!
//! You can also chain/modify these filters with standard boolean logic:
//!
//! Operator/Method | Description
//! ----------------|------------
//! `!`, `not` | Negate a filter using a locigal `NOT`
//! `&`, `and` | Combine two filters using a logical `AND`.
//! `\|`, `or` | Combine two filters using a logical `OR`.
//!
//! ### Executing a query
//!
//! After having finished building your query, you can simply call `.await`.
//! This will turn the builder into a [`Query`] object which is then executed asynchronously.
//!
//! A query will always return a `Result`.
//!
//! ## Raw queries
//!
//! Though these features are nice, they are not sufficient for most applications. This is why you can easily execute custom queries and still take advantage of automatic parsing, etc:
//!
//! ```ignore
//! // NOTE: You have to pass the exact type that Postgres is
//! // expecting. Doing otherwise will result in a runtime error.
//! let king_books = Book::query(r#"
//!         SELECT * FROM book
//!         JOIN author ON author.id = book.author_id
//!         WHERE POSITION(? in author.name) > 0
//!     "#,
//!     vec![&"King".to_string()]
//! ).await?;
//! assert_eq!(king_books.len(), 2);
//! ```
//!
//! ## License
//! This project is dual-licensed under the MIT and Apache 2.0 licenses.

#![deny(missing_docs)]

// This allows importing this crate's contents from pg-worm-derive.
extern crate self as pg_worm;

pub mod query;

use std::{ops::Deref, pin::Pin};

use deadpool_postgres::{
    Client as DpClient, GenericClient, Manager, ManagerConfig, Object, Pool,
    Transaction as DpTransaction,
};
use prelude::{Executable, Query, ToQuery};
pub use query::{Column, TypedColumn};
use query::{Delete, Update};

use crate::query::Select;
pub use async_trait::async_trait;
pub use pg::{NoTls, Row};
pub use pg_worm_derive::Model;
/// This crate's reexport of the `tokio_postgres` crate.
pub use tokio_postgres as pg;

use once_cell::sync::OnceCell;
use pg::types::ToSql;
use thiserror::Error;

/// This module contains all necessary imports to get you started
/// easily.
pub mod prelude {
    pub use crate::{
        connect_pool, force_register, register, FromRow, Model, NoTls, Queryable, Transaction,
    };

    pub use crate::query::{
        Column, Executable, NoneSet, Query, Select, SomeSet, ToQuery, TypedColumn,
    };
    pub use std::ops::Deref;
    pub use std::str::FromStr;

    pub use tokio_postgres::Config;
}

/// An enum representing the errors which are emitted by this crate.
#[derive(Error, Debug)]
pub enum Error {
    /// Something went wrong while connection to the database.
    #[error("couldn't connect to database")]
    NotConnected,
    /// There already is a connection to the database.
    #[error("already connected to database")]
    AlreadyConnected,
    /// No connection has yet been established.
    #[error("not connected to database")]
    ConnectionError(#[from] deadpool_postgres::CreatePoolError),
    /// No connection object could be created.
    #[error("couldn't build connection/config")]
    ConnectionBuildError(#[from] deadpool_postgres::BuildError),
    /// name
    #[error("couldn't fetch connection from pool")]
    PoolError(#[from] deadpool_postgres::PoolError),
    /// Errors emitted by the Postgres server.
    ///
    /// Most likely an invalid query.
    #[error("error communicating with database")]
    PostgresError(#[from] tokio_postgres::Error),
}

/// A trait signaling that a struct may be parsed from
/// a Postgres Row.
///
/// This being a new trait allows the exposure of a
/// derive macro for it.
pub trait FromRow: TryFrom<Row, Error = Error> {}

///
#[async_trait]
pub trait Queryable {
    /// Maps to tokio_postgres::Client::query.
    async fn query(&self, stmt: &str, params: &[&(dyn ToSql + Sync)]) -> Result<Vec<Row>, Error>;
    /// Maps to tokio_postgres::Client::execute.
    async fn execute(&self, stmt: &str, params: &[&(dyn ToSql + Sync)]) -> Result<u64, Error>;
}

#[async_trait]
impl<'a> Queryable for &Transaction<'a> {
    async fn query(&self, stmt: &str, params: &[&(dyn ToSql + Sync)]) -> Result<Vec<Row>, Error> {
        Ok(self.transaction.query(stmt, params).await?)
    }

    async fn execute(&self, stmt: &str, params: &[&(dyn ToSql + Sync)]) -> Result<u64, Error> {
        Ok(self.transaction.execute(stmt, params).await?)
    }
}

#[async_trait]
impl Queryable for &DpClient {
    async fn query(&self, stmt: &str, params: &[&(dyn ToSql + Sync)]) -> Result<Vec<Row>, Error> {
        Ok((***self).query(stmt, params).await?)
    }

    async fn execute(&self, stmt: &str, params: &[&(dyn ToSql + Sync)]) -> Result<u64, Error> {
        Ok((***self).execute(stmt, params).await?)
    }
}

/// This is the trait which you should derive for your model structs.
///
/// It provides the ORM functionality.
///
#[async_trait]
pub trait Model<T>: FromRow {
    /// This is a library function needed to derive the `Model`trait.
    ///
    /// *_DO NOT USE_*
    #[doc(hidden)]
    #[must_use]
    fn _table_creation_sql() -> &'static str;

    /// Returns a slice of all columns this model's table has.
    fn columns() -> &'static [&'static dyn Deref<Target = Column>];

    /// Returns the name of this model's table's name.
    fn table_name() -> &'static str;

    /// Start building a `SELECT` query which will be parsed to this model.
    fn select<'a>() -> Select<'a, Vec<T>>;

    /// Start building a `SELECT` query which returns either
    /// one entity or `None`.
    fn select_one<'a>() -> Select<'a, Option<T>>;

    /// Start building an `UPDATE` query.
    ///
    /// Returns the number of rows affected.
    fn update<'a>() -> Update<'a>;

    /// Start building a `DELETE` query.
    ///
    /// Returns the number or rows affected.
    fn delete<'a>() -> Delete<'a>;

    /// Build a raw query by passing in a statement along with
    /// arguments.
    ///
    /// You can reference the params by using `?` as a placeholder.
    fn query(_: impl Into<String>, _: Vec<&(dyn ToSql + Sync)>) -> Query<'_, Vec<T>>;
}

static POOL: OnceCell<Pool> = OnceCell::new();

/// Access the global connection pool.
#[doc = "hidden"]
pub fn get_pool() -> Result<&'static Pool, Error> {
    if let Some(pool) = POOL.get() {
        Ok(pool)
    } else {
        Err(Error::NotConnected)
    }
}

/// Try to fetch a client from the connection pool.
pub async fn fetch_client() -> Result<DpClient, Error> {
    Ok(get_pool()?.get().await?)
}

/// Initialize a gobal pool connected to the database server.
pub async fn connect_pool(config: tokio_postgres::Config) -> Result<(), Error> {
    let manager_config = ManagerConfig {
        recycling_method: deadpool_postgres::RecyclingMethod::Fast,
    };
    let manager = Manager::from_config(config, NoTls, manager_config);
    let pool = Pool::builder(manager).build()?;

    match POOL.set(pool) {
        Ok(_) => Ok(()),
        Err(_) => Err(Error::AlreadyConnected),
    }
}

/// Wrapper around the deadpool transaction which is
/// itself a wrapper around the tokio-postgres transaction.
///
/// This struct allows creatleting transactions without
/// having to care about passing a client.
pub struct Transaction<'a> {
    transaction: DpTransaction<'a>,
    _client: Pin<Box<DpClient>>,
}

impl<'a> Transaction<'a> {
    async fn new(client: DpClient) -> Result<Transaction<'a>, Error> {
        let client = Box::pin(client);
        let client_pointer = (&*client) as *const Object as *mut Object;

        // Trust me, bro
        let transaction = unsafe { &mut *client_pointer }.transaction().await?;

        Ok(Transaction {
            _client: client,
            transaction,
        })
    }

    /// Begin a new transaction.
    pub async fn begin() -> Result<Transaction<'a>, Error> {
        let client = fetch_client().await?;

        Transaction::new(client).await
    }

    /// Rollback this transaction.
    pub async fn rollback(self) -> Result<(), Error> {
        Ok(self.transaction.rollback().await?)
    }

    /// Commit the transaction.
    pub async fn commit(self) -> Result<(), Error> {
        Ok(self.transaction.commit().await?)
    }

    ///
    pub async fn execute<'b, Q, T>(&self, mut query: Q) -> Result<T, Error>
    where
        Q: ToQuery<'b, T>,
        Query<'b, T>: Executable<Output = T>,
    {
        let query = query.to_query();
        query.exec_with(self).await
    }
}

/// Register your model with the database.
/// This creates a table representing your model.
///
/// Use the [`register!`] macro for a more convenient api.
///
/// # Usage
/// ```ignore
/// #[derive(Model)]
/// struct Foo {
///     #[column(primary_key)]
///     id: i64
/// }
///
/// #[tokio::main]
/// async fn main() -> Result<(), pg_worm::Error> {
///     // ---- snip connection setup ----
///     pg_worm::register_model::<M>().await?;
/// }
/// ```
pub async fn register_model<M: Model<M>>() -> Result<(), Error>
where
    Error: From<<M as TryFrom<Row>>::Error>,
{
    let client = fetch_client().await?;
    client.batch_execute(M::_table_creation_sql()).await?;

    Ok(())
}

/// Same as [`register_model`] but if a table with the same name
/// already exists, it is dropped instead of returning an error.
pub async fn force_register_model<M: Model<M>>() -> Result<(), Error>
where
    Error: From<<M as TryFrom<Row>>::Error>,
{
    let client = fetch_client().await?;
    let query = format!(
        "DROP TABLE IF EXISTS {} CASCADE; ",
        M::columns()[0].table_name()
    ) + M::_table_creation_sql();

    client.batch_execute(&query).await?;

    Ok(())
}

/// Registers a [`Model`] with the database by creating a
/// corresponding table.
///
/// This is just a more convenient version api
/// for the [`register_model`] function.
///
/// This macro, too, requires the `tokio` crate.
///
/// Returns an error if:
///  - a table with the same name already exists,
///  - the client is not connected,
///  - the creation of the table fails
///
/// # Usage
///
/// ```ignore
/// use pg_worm::prelude::*;
///
/// #[derive(Model)]
/// struct Foo {
///     id: i64
/// }
///
/// #[tokio::main]
/// async fn main() -> Result<(), pg_worm::Error> {
///     // ---- snip connection setup ----
///     register!(Foo)?;
/// }
/// ```
#[macro_export]
macro_rules! register {
    ($($x:ty),+) => {
        tokio::try_join!(
            $($crate::register_model::<$x>()),*
        )
    };
}

/// Like [`register!`] but if a table with the same name already
/// exists, it is dropped instead of returning an error.
#[macro_export]
macro_rules! force_register {
    ($($x:ty),+) => {
        tokio::try_join!(
            $($crate::force_register_model::<$x>()),*
        )
    };
}
