use std::ops::{BitAnd, BitOr, Not};

use tokio_postgres::types::ToSql;

/// Struct for filtering your queries. Maps
/// to the `WHERE` clause of your query.
///
/// _These are automatically generated by operations
/// like `MyModel::my_field.eq(5)`. **You are not supposed to
/// construct them manually.**_
///
/// Stores the statement
/// and arguments. The statement should include placeholders
/// in the form of `$1`, `$2` and so on.
#[must_use]
pub struct Filter {
    args: Vec<Box<dyn ToSql + Sync>>,
    stmt: String,
}

impl Filter {
    pub(crate) fn new(stmt: impl Into<String>, args: Vec<Box<dyn ToSql + Sync>>) -> Filter {
        Filter {
            stmt: stmt.into(),
            args,
        }
    }

    /// Creates a new filter which doesn't filter anything.
    pub fn all() -> Filter {
        Filter::new("", Vec::new())
    }

    /// Access the filter's raw sql statement.
    ///
    #[inline]
    pub fn stmt(&self) -> &str {
        &self.stmt
    }

    #[inline]
    pub fn args(&self) -> &Vec<Box<dyn ToSql + Sync>> {
        &self.args
    }

    #[inline]
    pub fn take_args(self) -> Vec<Box<dyn ToSql + Sync>> {
        self.args
    }

    fn combine_with_sep(mut f1: Filter, mut f2: Filter, sep: &str) -> Filter {
        if f1.stmt().trim().is_empty() {
            return f2;
        }

        if f2.stmt().trim().is_empty() {
            return f1;
        }

        f1.stmt.push_str(sep);
        f1.stmt.push_str(&f2.stmt);
        f1.args.append(&mut f2.args);

        Filter::new(f1.stmt, f1.args)
    }

    #[inline]
    pub fn to_sql(&self) -> String {
        if self.stmt.trim().is_empty() {
            String::new()
        } else {
            // Replace question marks with numbered dollar signs
            let with_question_marks = format!("WHERE {}", self.stmt);

            Filter::question_mark_to_numbered_dollar(with_question_marks)
        }
    }

    pub(crate) fn question_mark_to_numbered_dollar(query: String) -> String {
        let mut res = String::with_capacity(query.len() + 10);

        // e.g. "WHERE ? < ?" -> "WHERE $1 < $2"
        let mut last_index = 0;
        let mut counter = 1;
        for (index, _) in query.match_indices('?') {
            // Push everything until the question mark
            res.push_str(&query[last_index..index]);
            // Push dollar sign with number
            res.push_str(&format!("${counter}"));
            // Update last index and counter
            last_index = index + 1;
            counter += 1;
        }

        // Push the tail
        res.push_str(&query[last_index..]);

        res
    }
}

impl BitAnd for Filter {
    type Output = Filter;

    fn bitand(self, rhs: Self) -> Self::Output {
        Filter::combine_with_sep(self, rhs, " AND ")
    }
}

impl BitOr for Filter {
    type Output = Filter;

    fn bitor(self, rhs: Self) -> Self::Output {
        Filter::combine_with_sep(self, rhs, " OR ")
    }
}

impl Not for Filter {
    type Output = Filter;

    fn not(mut self) -> Self::Output {
        self.stmt = format!("NOT ({})", self.stmt);

        self
    }
}

#[cfg(test)]
mod tests {
    use crate::Filter;

    #[test]
    fn question_marks_to_numbered_dollar() {
        let input = "WHERE ? < ?";
        assert_eq!(
            Filter::question_mark_to_numbered_dollar(input.into()),
            "WHERE $1 < $2"
        )
    }

    #[test]
    fn question_marks_to_numbered_dollar_empty() {
        let input = "";
        assert_eq!(Filter::question_mark_to_numbered_dollar(input.into()), "")
    }

    #[test]
    fn question_marks_to_numbered_dollar_none() {
        let input = "WHERE A < B";
        assert_eq!(
            Filter::question_mark_to_numbered_dollar(input.into()),
            "WHERE A < B"
        )
    }
}
