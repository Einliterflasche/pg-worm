#![allow(dead_code)]

use pg_worm::prelude::*;
use tokio::try_join;

#[derive(Model)]
struct Book {
    #[column(primary_key, auto)]
    id: i64,
    #[column(unique)]
    title: String,
    sub_title: Option<String>,
    pages: Vec<String>,
    author_id: i64,
}

#[derive(Model)]
struct Author {
    #[column(primary_key, auto)]
    id: i64,
    name: String,
}

#[tokio::test]
async fn complete_procedure() -> Result<(), pg_worm::Error> {
    // First create a connection. This can be only done once.
    connect!("postgres://me:me@localhost:5432", NoTls).await?;

    // Then, register the model with the pg_worm client.
    // Use `register!` if you want to fail if a
    // table with the same name already exists.
    //
    // `force_register` drops the old table,
    // which is useful for development.
    //
    // If your tables already exist, skip this part.
    force_register!(Author, Book)?;

    // Next, insert some data.
    // This works by passing values for all
    // fields which aren't autogenerated.
    try_join!(
        Author::insert("Stephen King"),
        Author::insert("Martin Luther King"),
        Author::insert("Karl Marx"),
        Book::insert("Foo - Part I", "Subtitle".to_string(), vec!["Page 1".to_string()], 1),
        Book::insert("Foo - Part II", None, vec![], 2),
        Book::insert("Foo - Part III", None, vec![], 3)
    )?;

    // Let's start with a simple query for all books.
    let books: Vec<Book> = Book::select(Filter::all()).await;
    assert_eq!(books.len(), 3);

    // Or search for a specific book
    let book = Book::select_one(Book::title.like("Foo%II")).await;
    assert!(book.is_some());
    assert!(book.unwrap().sub_title.is_none());

    // Or make more complex queries using the query builder:

    // Select all books written by an author named `King`
    let king_books: Vec<Book> = QueryBuilder::<Select>::new(Book::COLUMNS)
        .filter(Author::name.like("%King%")) // Matches all names which include `King`
        .join(&Book::author_id, &Author::id, JoinType::Inner)
        .build()
        .exec().await?
        .to_model()?;
    assert_eq!(king_books.len(), 2);

    // Select all books with at least one pages.
    let books_with_pages: Vec<Book> = QueryBuilder::<Select>::new(Book::COLUMNS)
        .filter(!Book::pages.empty())
        .build()
        .exec()
        .await?
        .to_model()?;
    assert_eq!(books_with_pages.len(), 1);

    // Select all books without a subtitle.
    let books_without_sub: Vec<Book> = QueryBuilder::<Select>::new(Book::COLUMNS)
        .filter(Book::sub_title.null())
        .build()
        .exec()
        .await?
        .to_model()?;
    assert_eq!(books_without_sub.len(), 2);

    // Or delete a book, you don't like
    Book::delete(Book::title.eq("Foo - Part II")).await;

    Ok(())
}
