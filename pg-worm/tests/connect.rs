#![allow(dead_code)]

use pg_worm::prelude::*;

#[derive(Model)]
struct Book {
    #[column(primary_key, auto)]
    id: i64,
    title: String,
    sub_title: Option<String>,
    pages: Vec<String>,
    author_id: i64,
}

#[derive(Model)]
struct Author {
    #[column(primary_key, auto)]
    id: i64,
    name: String,
}

#[tokio::test]
async fn complete_procedure() -> Result<(), pg_worm::Error> {
    // First create a connection. This can be only done once.
    connect!("postgres://me:me@localhost:5432", NoTls).await?;

    // Then, register the model with the pg_worm client.
    // Use `register!` if you want to fail if a
    // table with the same name already exists.
    //
    // `force_register` drops the old table,
    // which is useful for development.
    //
    // If your tables already exist, skip this part.
    force_register!(Author, Book)?;

    // Next, insert some data.
    // This works by passing values for all
    // fields which aren't autogenerated.
    Author::insert("Stephen King").await?;
    Author::insert("Martin Luther King").await?;
    Author::insert("Karl Marx").await?;

    Book::insert(
        "Foo - Part I",
        "Subtitle".to_string(),
        vec!["Page 1".to_string()],
        1,
    )
    .await?;
    Book::insert("Foo - Part II", None, vec![], 2).await?;
    Book::insert("Foo - Part III", None, vec![], 3).await?;

    // Easily query for all books
    let books = Book::select().await?;
    assert_eq!(books.len(), 3);

    // Or check whether your favorite book is listed
    let manifesto = Book::select_one()
        .where_(Book::title.eq(&"The Communist Manifesto".into()))
        .await?;
    assert!(manifesto.is_none());

    // Or update your records
    let books_updated = Book::update().set(Book::title, &"Trolled".into()).await?;
    assert_eq!(books_updated, 3);

    // Or delete them, after they have become useless
    let books_deleted = Book::delete().await?;
    assert_eq!(books_deleted, 3);

    Ok(())
}
