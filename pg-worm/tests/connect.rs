use pg_worm::{connect, register, Filter, Model, NoTls, Query, QueryBuilder, force_register};

#[derive(Model)]
struct Book {
    #[column(primary_key, auto)]
    id: i64,
    #[column(unique)]
    title: String,
    author_id: i64,
}

#[derive(Model)]
struct Author {
    #[column(primary_key, auto)]
    id: i64,
    name: String,
}

async fn get_authors() -> Vec<Author> {
    let rows = Query::select(Author::COLUMNS)
        .filter(Author::id.eq(1))
        .build()
        .exec().await.expect("err executing");

    rows.iter()
        .map(|i| Author::try_from(i).expect("err fromming"))
        .collect::<Vec<_>>()
}

#[tokio::test]
async fn complete_procedure() -> Result<(), pg_worm::Error> {
    // First create a connection. This can be only done _once_.
    connect!("postgres://me:me@localhost:5432", NoTls).await?;

    // Then, register the model with the pg_worm client.
    // Use `register!` if you want to fail if a
    // table with the same name already exists.
    //
    // `force_register` drops the old table,
    // which is useful for development.
    force_register!(Author).await?;
    force_register!(Book).await?;    

    // Next, insert a new book.
    // This works by passing values for all
    // fields which aren't autogenerated.
    Book::insert("Foo - Part I", 1).await?;
    Book::insert("Foo - Part II", 1).await?;

    Author::insert("Marx").await?;

    let authors = get_authors().await;
    assert_eq!(authors.len(), 1);
    assert_eq!(authors[0].name, "Marx");

    let books: Vec<Book> = Book::select(Filter::all()).await;
    assert_eq!(books.len(), 2);

    // Or search for a specific book
    let book = Book::select_one(Book::title.like("Foo%II")).await;
    assert!(book.is_some());

    // Or delete a book, you don't like
    Book::delete(Book::title.eq("Foo - Part II")).await;

    Ok(())
}
